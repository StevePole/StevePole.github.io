/*! apis 2015-05-15 */
function ApiDesigner() {
    this.blankJson = function() {
        return {
            basePath: "http://api.example.com",
            apiVersion: 1,
            info: this.defaultInfo,
            authorizations: this.defaultAuthorizations,
            parameters: this.defaultGlobalParams,
            responseMessages: this.defaultResponseCodes,
            envelope: this.defaultEnvelope,
            apis: [],
            models: this.defaultModels,
            jsonp: this.defaultJsonp
        };
    }, this.defaultInfo = {
        title: "",
        description: "",
        termsOfServiceUrl: "",
        contact: "",
        license: "",
        licenseUrl: ""
    }, this.blankApi = function(pathType) {
        return {
            path: "",
            hidden: !1,
            disabled: !1,
            operations: {},
            supports: {},
            type: pathType,
            parent: "",
            child: "",
            operationMethods: [],
            pathUsesId: Swagger.pathTypeNeedsId(pathType),
            pathUsesChild: Swagger.pathTypeNeedsChild(pathType)
        };
    }, this.blankOperation = function(pathType, method) {
        var operation = {
            method: method,
            type: "string",
            parameters: [],
            responseMessages: [],
            summary: "",
            notes: "",
            nickname: "",
            usesEnvelope: !0,
            requiresAuth: !0,
            displayType: "string"
        };
        return operation;
    }, this.blankParameter = function() {
        return {
            name: "",
            description: "",
            required: !1,
            type: "string",
            paramType: "query",
            displayType: "string"
        };
    }, this.blankProperty = function() {
        return {
            name: "",
            description: "",
            type: "string",
            usedInResponses: !0,
            expectedInResponses: !0,
            usedInPosts: !0,
            usedInPuts: !0,
            required: !0,
            requiredPut: !0,
            isArray: !1,
            displayType: "string",
            displayModel: "",
            "enum": ""
        };
    }, this.blankModel = function(name) {
        return {
            id: name,
            name: name,
            properties: [],
            required: []
        };
    }, this.blankResponseMessage = function() {
        return {
            code: "",
            summary: "",
            reason: ""
        };
    }, this.blankResponseHeader = function() {
        return {
            name: "",
            description: "",
            example: "",
            pageOnly: !1
        };
    }, this.defaultGlobalParams = [ {
        name: "Version",
        description: "Optional value to reference earlier versions of the API.",
        type: "int32",
        paramType: "header",
        example: 0
    }, {
        name: "Accept",
        description: "The response format, defaults to JSON.",
        type: "string",
        "enum": [ "application/json", "application/xml" ],
        paramType: "header"
    }, {
        name: "jsonp",
        description: "Indicates the server should respond in JSONP format, the value should be the name of the callback.",
        type: "string",
        paramType: "query"
    }, {
        name: "method",
        description: "Some browsers do not support certain HTTP methods (e.g. PUT, PATCH, DELETE, HEAD), this optional parameter enables you to use a POST request but ask the server to treat the request as a PUT, PATCH or DELETE.",
        type: "string",
        "enum": [ "PUT", "PATCH", "DELETE", "HEAD" ],
        paramType: "query"
    }, {
        name: "offset",
        description: "For paged requests, specifies the offset from the first row in the collection to the first row returned, default 0.",
        type: "integer",
        format: "int64",
        paramType: "query",
        example: 0,
        pagedOnly: !0
    }, {
        name: "limit",
        description: "For paged requests, specifies the max number of rows to return, default is 20.",
        type: "integer",
        format: "int64",
        paramType: "query",
        example: 20,
        pagedOnly: !0
    }, {
        name: "sort",
        description: "For paged requests, specifies whether to reverse the sort order, default is 'asc'.",
        type: "string",
        "enum": [ "asc", "desc" ],
        paramType: "query",
        pagedOnly: !0
    } ], this.pagingParameters = [ {
        name: "offset",
        description: "For paged requests, specifies the offset from the first row in the collection to the first row returned, default 0.",
        type: "integer",
        format: "int64",
        displayType: "int64",
        paramType: "query",
        pagedOnly: !0
    }, {
        name: "limit",
        description: "For paged requests, specifies the max number of rows to return, default is 20.",
        type: "integer",
        format: "int64",
        displayType: "int64",
        paramType: "query",
        pagedOnly: !0
    }, {
        name: "sort",
        description: "For paged requests, specifies whether to reverse the sort order, default is 'asc'.",
        type: "string",
        "enum": [ "asc", "desc" ],
        displayType: "enum",
        paramType: "query",
        pagedOnly: !0
    } ], this.defaultJsonp = {
        supported: !1,
        callbackParameter: "jsonp",
        methodParameter: "method",
        always200: !0,
        errorModel: "error"
    }, this.defaultModels = {
        error: {
            id: "error",
            name: "error",
            isError: !0,
            properties: {
                code: {
                    name: "code",
                    description: "The HTTP error code",
                    type: "integer",
                    format: "int32",
                    example: "404",
                    purpose: "code",
                    isId: !0
                },
                name: {
                    name: "name",
                    description: "A short name for the error message",
                    type: "string",
                    format: "string",
                    example: "Not found",
                    purpose: "name"
                },
                message: {
                    name: "message",
                    description: "A human readable and client friendly error message",
                    type: "string",
                    format: "string",
                    example: "The API method does not exist",
                    purpose: "message"
                }
            },
            required: []
        },
        paging: {
            id: "paging",
            name: "paging",
            properties: {
                total: {
                    name: "total",
                    description: "The total number of items available.",
                    type: "integer",
                    format: "int64",
                    example: "200",
                    responsesOnly: !0,
                    isId: !0
                },
                next: {
                    name: "next",
                    description: "A link for the next page of data.",
                    type: "string",
                    format: "string",
                    example: "https://api.example.com/resource?offset=20&limit=20",
                    responsesOnly: !0
                },
                prev: {
                    name: "prev",
                    description: "A link for the previous page of data.",
                    type: "string",
                    format: "string",
                    example: "https://api.example.com/resource?offset=0&limit=20",
                    responsesOnly: !0
                },
                first: {
                    name: "first",
                    description: "A link for the first page of data.",
                    type: "string",
                    format: "string",
                    example: "https://api.example.com/resource?offset=0&limit=20",
                    responsesOnly: !0
                },
                last: {
                    name: "last",
                    description: "A link for the last page of data.",
                    type: "string",
                    format: "string",
                    example: "https://api.example.com/resource?offset=180&limit=20",
                    responsesOnly: !0
                }
            },
            required: []
        }
    }, this.defaultEnvelope = {
        mainParam: "response",
        properties: {
            response: {
                description: "The main response",
                expectedInResponses: !0,
                main: !0
            },
            paging: {
                description: "Information and links on how to navigate pages of this response",
                $ref: "paging",
                type: "paging",
                pagedOnly: !0,
                expectedInResponses: !0
            }
        }
    }, this.defaultResponseCodes = [ {
        code: 200,
        summary: "OK",
        reason: "Request completed successfully."
    }, {
        code: 400,
        summary: "Bad Request",
        reason: "Something was wrong with the request, incorrect parameters.",
        responseModel: "error"
    }, {
        code: 401,
        summary: "Unauthorized",
        reason: "Not authorised to access the requested data.",
        responseModel: "error"
    }, {
        code: 403,
        summary: "Forbidden",
        reason: "Authentication failed.",
        responseModel: "error"
    }, {
        code: 404,
        summary: "Not Found",
        reason: "The requested resource does not exist",
        responseModel: "error"
    }, {
        code: 408,
        summary: "Request Timeout",
        reason: "The operation timed out.",
        responseModel: "error"
    }, {
        code: 429,
        summary: "Rate Limited",
        reason: "You have exceeded your usage quota and your request has been rate limited.",
        responseModel: "error"
    }, {
        code: 500,
        summary: "Internal Server Error",
        reason: "Something went wrong with the server.",
        responseModel: "error"
    } ], this.defaultResponseHeaders = [ {
        name: "Content-Type",
        description: "The media type of the body",
        example: "application/json",
        pageOnly: !1
    }, {
        name: "Content-Length",
        description: "How many bytes the content body contains",
        example: "8584",
        pageOnly: !1
    }, {
        name: "Content-Encoding",
        description: "What, if any, compression is being used.",
        example: "gzip",
        pageOnly: !1
    }, {
        name: "ETag",
        description: "A short string representation of the resource, useful for seeing if it has changed.",
        example: "18118-50c9c7c55a41d",
        pageOnly: !1
    }, {
        name: "Last-Modified",
        description: "When was the resource last modified",
        example: "Wed, 14 Jan 2015 13:12:03 GMT",
        pageOnly: !1
    }, {
        name: "Link",
        description: "Links to other pages of data in the collection, valid values are: first, prev, next, last",
        example: "<https://api.example.com/resources?offset=20&limit=20>; rel='next', <https://api.example.com/resources?offset=60&limit=20>; rel='last'",
        pageOnly: !1,
        pagedOnly: !0
    }, {
        name: "X-Total-Count",
        description: "The number of items in the collection",
        example: "75",
        pageOnly: !1,
        pagedOnly: !0
    } ], this.defaultAuthorizations = {
        supports: {
            oauth2Implicit: !0,
            oauth2AuthorizationCode: !1
        },
        oauth2: {
            type: "oauth2",
            scopes: [],
            grantTypes: {
                implicit: {
                    loginEndpoint: {
                        url: ""
                    },
                    tokenName: "access_token"
                },
                authorization_code: {
                    tokenRequestEndpoint: {
                        url: "",
                        clientIdName: "client_id",
                        clientSecretName: "client_secret"
                    },
                    tokenEndpoint: {
                        url: "",
                        tokenName: "access_code"
                    }
                }
            }
        }
    };
}

function ApiService2($q) {
    this.dataPath = "api/apis/", this.create = function(token, json) {
        console && console.log && console.log("create");
        var url = this.dataPath + "?token=" + token;
        return this.request(url, "POST", json);
    }, this.update = function(token, id, json) {
        console && console.log && console.log("update");
        var url = this.dataPath + "?token=" + token + "&id=" + id;
        return this.request(url, "PUT", json);
    }, this.get = function(token, id) {
        var url = this.dataPath + "?token=" + token + "&id=" + id;
        return this.request(url, "GET");
    }, this["delete"] = function(token, id) {
        var url = this.dataPath + "?token=" + token + "&id=" + id;
        return this.request(url, "DELETE");
    }, this.getList = function(token) {
        var url = this.dataPath + "?token=" + token;
        return this.request(url, "GET");
    }, this.getPublishedList = function(isPublished) {
        var url = this.dataPath;
        return isPublished && (url += "?where=published"), this.request(url, "GET");
    }, this.getHistory = function(token, id) {
        var url = this.dataPath + "?token=" + token + "&path=history&id=" + id;
        return this.request(url, "GET");
    }, this.request = function(url, method, post) {
        var deferred = $q.defer(), settings = {
            async: !1,
            global: !1,
            url: url,
            type: method,
            dataType: "json",
            success: function(data) {
                data && data.error && deferred.reject(data.message ? data.message : "An unknown error occcurred."), 
                deferred.resolve(data);
            },
            error: function(xhr, status, errorThrown) {
                deferred.reject({
                    code: "",
                    error: errorThrown
                });
            }
        };
        return post && (settings.data = post), $.ajax(settings), deferred.promise;
    };
}

function ApiService($window, $http, $q, $routeParams, AuthService, ApiService2) {
    var self = this;
    this.local = $window.localStorage, this.apiListKey = "swagger-existing", this.list = [ "json/cds_swagger.json", "json/auth.json", "json/swift.json", "json/transferwise.json" ], 
    this.getRemoteApis = function() {
        return ApiService2.getPublishedList().then(function(apis) {
            return console && console.log && console.log(apis), _.map(apis, function(api) {
                return api.swagger.id = api.objectId, api.swagger;
            });
        });
    }, this.getPublishedApis = function() {
        var deferred = $q.defer(), calls = [];
        return _.each(this.list, function(apiPath) {
            calls.push($http.get(apiPath).then(function(response) {
                return response.data.link = apiPath, response.data;
            }, function(error) {
                return {
                    code: error.status,
                    message: "Couldn't find file",
                    error: !0
                };
            }));
        }), $q.all(calls).then(function(results) {
            deferred.resolve(results);
        }), deferred.promise;
    }, this.getLocalApis = function() {
        var deferred = $q.defer(), apiList = JSON.parse(this.local.getItem(this.apiListKey));
        apiList || (apiList = []);
        var localApis = [];
        return _.each(apiList, function(apiKey) {
            localApis.push(JSON.parse(this.local.getItem(apiKey)));
        }), deferred.resolve(localApis), deferred.promise;
    }, this.save = function(name, json) {
        var promise, token = AuthService.getToken();
        return promise = json.id ? ApiService2.update(token, json.id, json) : ApiService2.create(token, json), 
        promise.then(function(response) {
            return response && response.objectId && (json.id = response.objectId), response;
        }, function() {
            return {};
        })["finally"](function() {
            this.local.setItem(name, JSON.stringify(json)), self.saveToApiList(name);
        });
    }, this.load = function(name) {
        var deferred = $q.defer();
        return deferred.resolve(JSON.parse(this.local.getItem(name))), deferred.promise;
    }, this.loadRemote = function(url) {
        return $http.get(url).then(function(response) {
            return response.data;
        });
    }, this.remove = function(name) {
        var deferred = $q.defer();
        return this.removeFromApiList(name), deferred.resolve(this.local.removeItem(name)), 
        deferred.promise;
    }, this.saveToApiList = function(name) {
        var existingApis = JSON.parse(this.local.getItem(this.apiListKey));
        existingApis || (existingApis = {}), !existingApis[name] && name && (existingApis[name] = name), 
        this.local.setItem(this.apiListKey, JSON.stringify(existingApis));
    }, this.removeFromApiList = function(name) {
        var existingApis = JSON.parse(this.local.getItem(this.apiListKey));
        existingApis || (existingApis = {}), existingApis[name] && delete existingApis[name], 
        this.local.setItem(this.apiListKey, JSON.stringify(existingApis));
    }, this.clearApiList = function() {
        return this.local.removeItem(this.apiListKey);
    }, this.determineId = function() {
        return $routeParams.apiId ? $routeParams.apiId : this.getURLParameter("ls") ? this.getURLParameter("ls") : this.getURLParameter("json") ? this.getURLParameter("json") : !1;
    }, this.determineLoadType = function() {
        return $routeParams.apiId ? "remote" : this.getURLParameter("ls") ? "local" : this.getURLParameter("json") ? "remote" : !1;
    }, this.getById = function(id, type) {
        if ("local" === type) return this.load(id);
        if ("remote" === type) return this.loadRemote(id);
        var deferred = $q.defer();
        return deferred.reject(Error("Unrecognised load type.")), deferred.promise;
    }, this.getURLParameter = function(name) {
        return decodeURIComponent((RegExp(name + "=(.+?)(&|$)").exec($window.location.search) || [ "", "" ])[1]);
    };
}

function AuthService($window, $http) {
    this.userPath = "api/users/", this.setToken = function(token, expires_in) {
        AuthService.setToken(token, expires_in);
    }, this.getToken = function() {
        var sessionInfo = !1;
        try {
            sessionInfo = JSON.parse($window.localStorage.token);
        } catch (ex) {}
        return sessionInfo && sessionInfo.token && sessionInfo.expiresAt && sessionInfo.expiresAt > this.now() ? sessionInfo.token : !1;
    }, this.getPrivileges = function() {
        var url = this.userPath, token = this.getToken();
        return token && (url += "?token=" + token), $http.get(url).then(function(response) {
            return response.data.error ? [] : response.data.privileges;
        });
    }, this.openLogin = function() {
        var endPoint = "https://oauth.alchemysocial.com/oauth/login", redirect = "http%3A%2F%2Fsmartv2.alchemysocial.com%2FAlchemyApi%2Ftoken.php", client = "ApiTester";
        redirect = "http%3A%2F%2Flocalhost%2FAlchemyApi%2Ftoken.php", $window.open(endPoint + "?response_type=code&client_id=" + client + "&redirect_uri=" + redirect, "Login", "location=no, menubar=no, toolbar=no, scrollbars=no, resizable=no, width=340, height=340");
    }, this.logout = function() {
        $window.localStorage.token = JSON.stringify({
            token: !1
        });
    }, this.now = function() {
        var dateProvider = new Date();
        return Math.floor(dateProvider.getTime() / 1e3);
    };
}

function SwaggerDiff(Utility) {
    this.objectChanges = function() {
        return {
            changed: 0,
            breaking: [],
            nonbreaking: [],
            children: {}
        };
    }, this.listChanges = function() {
        return {
            changed: 0,
            added: [],
            removed: [],
            children: {}
        };
    }, this.diff = function(oldSwagger, newSwagger) {
        if (oldSwagger.prepped) throw new Error("oldSwagger JSON should not be prepped for display while diffing.");
        if (newSwagger.prepped) throw new Error("newSwagger JSON should not be prepped for display while diffing.");
        var changes = {
            breaking: [],
            nonbreaking: [],
            apis: {},
            models: {},
            envelope: {},
            global: {}
        };
        return changes.meta = this.objectChanges(), this.metaDiff(oldSwagger, newSwagger, changes.meta), 
        changes.envelope = this.objectChanges(), this.envelopeDiff(oldSwagger.envelope, newSwagger.envelope, changes.envelope), 
        changes.global = this.listChanges(), this.parametersDiff(oldSwagger.parameters, newSwagger.parameters, changes.global), 
        changes.apis = this.listChanges(), this.apisDiff(oldSwagger.apis, newSwagger.apis, changes.apis), 
        changes.models = this.listChanges(), this.modelsDiff(oldSwagger.models, newSwagger.models, changes.models), 
        changes.changed = changes.meta.changed + changes.envelope.changed + changes.global.changed + changes.apis.changed + changes.models.changed, 
        changes;
    }, this.metaDiff = function(oldSwagger, newSwagger, changes) {
        return this.checkObject(changes), oldSwagger.apiVersion !== newSwagger.apiVersion && changes.breaking.push("apiVersion was changed"), 
        oldSwagger.basePath !== newSwagger.basePath && changes.breaking.push("basePath was changed"), 
        oldSwagger.testPath !== newSwagger.testPath && changes.breaking.push("testPath was changed"), 
        oldSwagger.authRedirect !== newSwagger.authRedirect && changes.breaking.push("The authentication redirect URL was changed"), 
        oldSwagger.authParameter !== newSwagger.authParameter && changes.breaking.push("The authentication parameter was changed"), 
        this.infoDiff(oldSwagger.info, newSwagger.info, changes), changes.changed += changes.breaking.length + changes.nonbreaking.length, 
        changes.changed;
    }, this.infoDiff = function(oldInfo, newInfo, changes) {
        oldInfo.title !== newInfo.title && changes.nonbreaking.push("Title was changed"), 
        oldInfo.contact !== newInfo.contact && changes.nonbreaking.push("Contact was changed"), 
        oldInfo.description !== newInfo.description && changes.nonbreaking.push("Description was changed");
    }, this.genericParamDiff = function(oldParameter, newParameter, changes) {
        return this.checkObject(changes), oldParameter.type !== newParameter.type && changes.breaking.push("Type was changed from '" + oldParameter.type + "' to '" + newParameter.type + "'"), 
        oldParameter.isDictionary !== newParameter.isDictionary && changes.breaking.push("Type " + (newParameter.isDictionary ? "now" : "no longer") + " a dictionary"), 
        oldParameter.$ref !== newParameter.$ref && changes.breaking.push("$ref was changed from '" + oldParameter.$ref + "' to '" + newParameter.$ref + "'"), 
        oldParameter.items && !newParameter.items ? changes.breaking.push("No longer an array type response") : !oldParameter.items && newParameter.items ? changes.breaking.push("Now an array response") : oldParameter.items && newParameter.items && (oldParameter.items.$ref !== newParameter.items.$ref && changes.breaking.push("items.$ref was changed from '" + oldParameter.items.$ref + "' to '" + newParameter.items.$ref + "'"), 
        oldParameter.items.type !== newParameter.items.type && changes.breaking.push("items.type was changed from '" + oldParameter.items.type + "' to '" + newParameter.items.type + "'")), 
        oldParameter.format !== newParameter.format && (oldParameter.format ? changes.breaking.push("Format was changed from '" + oldParameter.format + "' to '" + newParameter.format + "'") : changes.nonbreaking.push("Format was added '" + newParameter.format + "'")), 
        oldParameter.description !== newParameter.description && changes.nonbreaking.push("Description was changed"), 
        oldParameter.example !== newParameter.example && changes.nonbreaking.push("Example value was changed"), 
        oldParameter.notes !== newParameter.notes && changes.nonbreaking.push("Notes were changed"), 
        oldParameter["enum"] !== newParameter["enum"], changes.changed += changes.breaking.length + changes.nonbreaking.length, 
        changes.changed;
    }, this.envelopeDiff = function(oldEnvelope, newEnvelope, changes) {
        return this.checkObject(changes), changes.children = this.listChanges(), this.propertiesDiff(oldEnvelope.properties, newEnvelope.properties, changes.children);
    }, this.apisDiff = function(oldApis, newApis, changes) {
        var swaggerDiff = this;
        this.checkList(changes);
        var oldApiMap = Utility.arrayToMap(oldApis, "path"), newApiMap = Utility.arrayToMap(newApis, "path"), oldApiPaths = _.keys(oldApiMap), newApiPaths = _.keys(newApiMap), pathsInBoth = _.intersection(oldApiPaths, newApiPaths);
        return _.each(pathsInBoth, function(path) {
            changes.children[path] = swaggerDiff.objectChanges(), changes.changed += swaggerDiff.apiDiff(oldApiMap[path], newApiMap[path], changes.children[path]);
        }), changes.removed = _.difference(oldApiPaths, newApiPaths), changes.added = _.difference(newApiPaths, oldApiPaths), 
        changes.changed += changes.removed.length + changes.added.length, changes.changed;
    }, this.apiDiff = function(oldApi, newApi, changes) {
        return oldApi.description !== newApi.description && changes.nonbreaking.push(oldApi.description ? "Description was changed" : "Description was added"), 
        changes.children = this.listChanges(), changes.changed = this.operationsDiff(oldApi.operations, newApi.operations, changes.children), 
        changes.changed += changes.breaking.length + changes.nonbreaking.length, changes.changed;
    }, this.operationsDiff = function(oldOperations, newOperations, changes) {
        var swaggerDiff = this;
        this.checkList(changes);
        var oldOperationMap = Utility.arrayToMap(oldOperations, "method"), newOperationMap = Utility.arrayToMap(newOperations, "method"), oldMethods = _.keys(oldOperationMap), newMethods = _.keys(newOperationMap), methodsInBoth = _.intersection(oldMethods, newMethods);
        return _.each(methodsInBoth, function(method) {
            changes.children[method] = swaggerDiff.objectChanges(), changes.changed += swaggerDiff.operationDiff(oldOperationMap[method], newOperationMap[method], changes.children[method]);
        }), changes.removed = _.difference(oldMethods, newMethods), changes.added = _.difference(newMethods, oldMethods), 
        changes.changed += changes.removed.length + changes.added.length, changes.changed;
    }, this.operationDiff = function(oldOperation, newOperation, changes) {
        return this.checkObject(changes), oldOperation.type !== newOperation.type && changes.breaking.push("Response type was changed from '" + oldOperation.type + "' to '" + newOperation.type + "'"), 
        oldOperation.items && newOperation.items && (oldOperation.items.$ref !== newOperation.items.$ref && changes.breaking.push("Array type was changed from '" + oldOperation.items.$ref + "' to '" + newOperation.items.$ref + "'"), 
        oldOperation.items.type !== newOperation.items.type && changes.breaking.push("Array type was changed from '" + oldOperation.items.type + "' to '" + newOperation.items.type + "'")), 
        oldOperation.requiresAuth && !newOperation.requiresAuth ? changes.breaking.push("No longer requires Auth") : !oldOperation.requiresAuth && newOperation.requiresAuth && changes.breaking.push("Now requires Auth"), 
        oldOperation.isDictionary && !newOperation.isDictionary ? changes.breaking.push("No longer a dictionary") : !oldOperation.disabled && newOperation.disabled && changes.breaking.push("Now a dictionary"), 
        oldOperation.format !== newOperation.format && changes.breaking.push("Format was changed from '" + oldOperation.format + "' to '" + newOperation.format + "'"), 
        oldOperation.summary !== newOperation.summary && changes.nonbreaking.push("Summary was changed"), 
        oldOperation.notes !== newOperation.notes && changes.nonbreaking.push("Notes were changed"), 
        oldOperation.example !== newOperation.example && changes.nonbreaking.push("Example response was changed"), 
        oldOperation.disabled && !newOperation.disabled ? changes.breaking.push("No longer disabled") : !oldOperation.disabled && newOperation.disabled && changes.breaking.push("Now disabled"), 
        oldOperation.hidden && !newOperation.hidden ? changes.breaking.push("No longer hidden") : !oldOperation.hidden && newOperation.hidden && changes.breaking.push("Now hidden"), 
        oldOperation.isPaged && !newOperation.isPaged ? changes.breaking.push("No longer paged") : !oldOperation.isPaged && newOperation.isPaged && changes.breaking.push("Now paged"), 
        oldOperation.defaultPageSize !== newOperation.defaultPageSize && changes.nonbreaking.push("Default page size was changed"), 
        oldOperation.maxPageSize !== newOperation.maxPageSize && changes.nonbreaking.push("Max page size was changed"), 
        changes.children = this.listChanges(), changes.changed = this.parametersDiff(oldOperation.parameters, newOperation.parameters, changes.children), 
        changes.changed += changes.breaking.length + changes.nonbreaking.length, changes.changed;
    }, this.parametersDiff = function(oldParams, newParams, changes) {
        var swaggerDiff = this;
        this.checkList(changes);
        var oldParamMap = Utility.arrayToMap(oldParams, "name"), newParamMap = Utility.arrayToMap(newParams, "name"), oldParamNames = _.keys(oldParamMap), newParamNames = _.keys(newParamMap), paramsInBoth = _.intersection(oldParamNames, newParamNames);
        return _.each(paramsInBoth, function(name) {
            changes.children[name] = swaggerDiff.objectChanges(), changes.changed += swaggerDiff.parameterDiff(oldParamMap[name], newParamMap[name], changes.children[name]);
        }), changes.removed = _.difference(oldParamNames, newParamNames), changes.added = _.difference(newParamNames, oldParamNames), 
        changes.changed += changes.removed.length + changes.added.length, changes.changed;
    }, this.parameterDiff = function(oldParameter, newParameter, changes) {
        return this.checkObject(changes), changes.changed = this.genericParamDiff(oldParameter, newParameter, changes), 
        oldParameter.paramType !== newParameter.paramType && changes.breaking.push("paramType was changed from '" + oldParameter.paramType + "' to '" + newParameter.paramType + "'"), 
        oldParameter.required !== newParameter.required && changes.breaking.push(newParameter.required ? "Now required" : "No longer required"), 
        changes.changed += changes.breaking.length + changes.nonbreaking.length, changes.changed;
    }, this.modelsDiff = function(oldModels, newModels, changes) {
        var swagggerDiff = this;
        this.checkList(changes);
        var oldModelNames = _.keys(oldModels), newModelNames = _.keys(newModels), modelsInBoth = _.intersection(oldModelNames, newModelNames);
        return _.each(modelsInBoth, function(name) {
            changes.children[name] = swagggerDiff.objectChanges(), changes.changed += swagggerDiff.modelDiff(oldModels[name], newModels[name], changes.children[name]);
        }), changes.removed = _.difference(oldModelNames, newModelNames), changes.added = _.difference(newModelNames, oldModelNames), 
        changes.changed += changes.removed.length + changes.added.length, changes.changed;
    }, this.modelDiff = function(oldModel, newModel, changes) {
        return this.checkObject(changes), changes.children = this.listChanges(), changes.changed = this.propertiesDiff(oldModel.properties, newModel.properties, changes.children), 
        oldModel.onlyIdsForNestedPosts !== newModel.onlyIdsForNestedPosts && changes.breaking.push(newModel.onlyIdsForNestedPosts ? "Now only ids when nested in POSTs" : "Now all properties when nested in POSTs"), 
        changes;
    }, this.propertiesDiff = function(oldProperties, newProperties, changes) {
        var swaggerDiff = this;
        this.checkList(changes);
        var oldPropertiesMap = Utility.arrayToMap(oldProperties, "name"), newPropertiesMap = Utility.arrayToMap(newProperties, "name"), oldPropertyNames = _.keys(oldPropertiesMap), newPropertyNames = _.keys(newPropertiesMap), paramsInBoth = _.intersection(oldPropertyNames, newPropertyNames);
        return _.each(paramsInBoth, function(name) {
            changes.children[name] = swaggerDiff.objectChanges(), changes.changed += swaggerDiff.propertyDiff(oldPropertiesMap[name], newPropertiesMap[name], changes.children[name]);
        }), changes.removed = _.difference(oldPropertyNames, newPropertyNames), changes.added = _.difference(newPropertyNames, oldPropertyNames), 
        changes.changed += changes.removed.length + changes.added.length, changes.changed;
    }, this.propertyDiff = function(oldProperty, newProperty, changes) {
        return this.checkObject(changes), changes.changed = this.genericParamDiff(oldProperty, newProperty, changes), 
        oldProperty.usedInResponses !== newProperty.usedInResponses && changes.breaking.push(newProperty.usedInResponses ? "Now used in responses" : "No longer used in responses"), 
        oldProperty.expectedInResponses !== newProperty.expectedInResponses && changes.breaking.push(newProperty.expectedInResponses ? "Now expected in all responses" : "No longer expected in all responses"), 
        oldProperty.usedInPuts !== newProperty.usedInPuts && changes.breaking.push(newProperty.usedInPuts ? "Now used in updates" : "No longer used in updates"), 
        oldProperty.requiredPut !== newProperty.requiredPut && changes.breaking.push(newProperty.requiredPut ? "Now required in update operations" : "No longer required in update operations"), 
        oldProperty.usedInPosts !== newProperty.usedInPosts && changes.breaking.push(newProperty.usedInPosts ? "Now used in creates" : "No longer used in creates"), 
        oldProperty.required !== newProperty.required && changes.breaking.push(newProperty.required ? "Now required in create operations" : "No longer required in create operations"), 
        changes.changed += changes.breaking.length + changes.nonbreaking.length, changes.changed;
    }, this.checkList = function(changes) {
        if (!changes.added || !changes.removed) throw new Error("Incorret changes format, should be list type");
    }, this.checkObject = function(changes) {
        if (!changes.breaking || !changes.nonbreaking) throw new Error("Incorret changes format, should be object type");
    };
}

function Swagger(Utility) {
    this.deleteEnvelopeModels = function(models) {
        var swagger = this;
        return _.each(models, function(model, modelName) {
            swagger.modelIsEnvelope(modelName) && delete models[modelName];
        }), models;
    }, this.createEnvelopeModel = function(operation, envelopeModel, models) {
        if (operation.usesEnvelope) {
            var prospectiveEnvelopeName;
            if (prospectiveEnvelopeName = "object" === operation.displayType ? this.getModelEnvelopeName(operation.displayModel, operation.isArray, operation.isDictionary, operation.isPaged) : this.getModelEnvelopeName(operation.displayType, operation.isArray, operation.isDictionary, operation.isPaged), 
            !models[prospectiveEnvelopeName]) {
                var newEnvelope = $.extend(!0, {}, envelopeModel);
                newEnvelope.envelope = !0;
                var mainParameter = newEnvelope.properties[envelopeModel.mainParam];
                if (!mainParameter) throw Utility.log(envelopeModel), new Error("mainParamName '" + envelopeModel.mainParam + "' is not in envelopeModel.");
                if (!operation.displayType) throw Utility.log(operation), new Error("Operation should have a displayType.");
                if (Swagger.modelIsEnvelope(operation.displayType)) throw Utility.log(operation), 
                new Error("Operation should not have an envelope displayType.");
                if (this.displayTypesToSwaggerTypes(mainParameter, operation, !0), Swagger.modelIsEnvelope(mainParameter.type)) throw Utility.log(mainParameter), 
                Utility.log(operation), new Error("Main parameter type '" + mainParameter.type + "' should not be an envelope.");
                if (mainParameter.$ref && this.typesAndFormats[mainParameter.$ref]) throw new Error("mainParameter.$ref '" + mainParameter.$ref + "' should not be a simple type.");
                return operation.isPaged || _.each(newEnvelope.properties, function(property, idx) {
                    property.pagedOnly && delete newEnvelope.properties[idx];
                }), mainParameter.displayType = operation.displayType, mainParameter.displayModel = operation.displayModel, 
                mainParameter.isArray = operation.isArray, operation.type = prospectiveEnvelopeName, 
                operation.$ref = prospectiveEnvelopeName, models[prospectiveEnvelopeName] = newEnvelope, 
                !0;
            }
            return operation.type = prospectiveEnvelopeName, operation.$ref = prospectiveEnvelopeName, 
            !1;
        }
    }, this.addPostDataParameters = function(json) {
        var swagger = this;
        _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                if (operation.postDataModel) {
                    if (json.models instanceof Array) throw new Error("json.models ahould be an object at this point.");
                    var model = swagger.getModelByName(json.models, operation.postDataModel);
                    if (!model) throw new Error("Model not found: " + operation.postDataModel);
                    operation.parameters = _.filter(operation.parameters, function(parameter) {
                        return "body" !== parameter;
                    }), _.each(model.properties, function(property) {
                        if (!(swagger.methodIsCreate(operation.method) && !property.usedInPosts || swagger.methodIsUpdate(operation.method) && !property.usedInPuts)) {
                            var pathSections = swagger.pathSections(api.path);
                            if (!Swagger.pathTypeNeedsId(pathSections.type) || !swagger.modelPropertyIsId(property)) {
                                var param = $.extend(!0, {}, property);
                                param.paramType = "body", swagger.methodIsUpdate(operation.method) && property.requiredPut || swagger.methodIsCreate(operation.method) && property.required ? param.required = !0 : delete param.required, 
                                delete param.requiredPut, delete param.example, delete param.usedInResponses, delete param.usedInPosts, 
                                delete param.usedInPuts, delete param.displayType, operation.parameters.push(param);
                            }
                        }
                    });
                }
            });
        });
    }, this.addPathParameters = function(json) {
        var swagger = this;
        _.each(json.apis, function(api) {
            var pathSections = swagger.pathSections(api.path), apiType = pathSections.type;
            if (Swagger.pathTypeNeedsId(apiType)) {
                if (!api.parentModel) return;
                var model = swagger.getModelByName(json.models, api.parentModel);
                if (!model) throw new Error(api.parentModel + " model not found.");
                var idProperty;
                _.each(model.properties, function(property) {
                    property.isId && (idProperty = property);
                });
                var apiDesigner = new ApiDesigner(), pathParameter = apiDesigner.blankParameter();
                pathParameter.name = idProperty.name, pathParameter.description = idProperty.description, 
                pathParameter.type = idProperty.type, pathParameter.format = idProperty.format, 
                pathParameter.required = !0, pathParameter.paramType = "path", delete pathParameter.displayType, 
                _.each(api.operations, function(operation) {
                    operation.parameters.unshift(pathParameter);
                });
            }
        });
    }, this.addGlobalParameters = function(json) {
        _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                _.each(json.parameters, function(parameter) {
                    if (!parameter.pagedOnly || operation.isPaged) {
                        var paramCopy = $.extend(!0, parameter, {});
                        paramCopy.global = !0, delete paramCopy.displayType, operation.parameters.push(paramCopy);
                    }
                });
            });
        });
    }, this.modelPropertyIsId = function(property) {
        return property.isId;
    }, this.getResponseModelForOperation = function(operation, models) {
        return operation.displayModel && models[operation.displayModel] ? models[operation.displayModel] : !1;
    }, this.getModelsUsedInResponses = function(json) {
        if (json.prepped) throw new Error("JSON should not be prepped when running this function.");
        var responseModels = {};
        return _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                operation.$ref ? responseModels[operation.$ref] = json.models[operation.$ref] : operation.items && operation.items.$ref ? responseModels[operation.items.$ref] = json.models[operation.items.$ref] : operation.type && (responseModels[operation.type] = {
                    format: operation.format
                });
            });
        }), responseModels;
    }, this.inferEnvelope = function(json, models) {
        var swagger = this;
        if (json.envelope) return json.envelope;
        var envelopeProperties = {}, propertyTypeCount = {};
        _.each(models, function(model, modelName) {
            swagger.modelIsEnvelope(modelName) && _.each(model.properties, function(property) {
                envelopeProperties[property.name] || (envelopeProperties[property.name] = property, 
                propertyTypeCount[property.name] = {}), propertyTypeCount[property.name][property.type] || (propertyTypeCount[property.name][property.type] = 1);
            });
        });
        var maxTypes = 0, mainProperty = !1;
        return _.each(propertyTypeCount, function(types, propertyName) {
            _.size(types) > maxTypes && (maxTypes = _.size(types), mainProperty = propertyName);
        }), mainProperty && (envelopeProperties[mainProperty].main = !0), {
            mainParam: mainProperty,
            properties: envelopeProperties
        };
    }, this.inferPostModels = function(apis, models) {
        if (models.push) throw new Error("models should not be an array by this point.");
        var swagger = this, modelProperties = {};
        _.each(models, function(model, modelName) {
            swagger.modelIsEnvelope(modelName) || (modelProperties[modelName] = [], _.each(model.properties, function(property, propertyName) {
                property.responsesOnly || modelProperties[modelName].push(propertyName);
            }));
        }), _.each(apis, function(api) {
            _.each(api.operations, function(operation) {
                var postDataModel = !1;
                !operation.postDataModel && swagger.methodSupportsPostData(operation.method) && (postDataModel = swagger.inferParamsAreModel(operation, modelProperties)), 
                postDataModel && (operation.postDataModel = postDataModel);
            });
        });
    }, this.inferParamsAreModel = function(operation, modelProperties) {
        var operationProperties = [], postDataModel = !1;
        return _.each(operation.parameters, function(parameter) {
            ("body" === parameter.paramType || "path" === parameter.paramType) && operationProperties.push(parameter.name);
        }), "POST" === operation.method && operationProperties.push("id"), operationProperties.length && _.each(modelProperties, function(properties, modelName) {
            properties.length === operationProperties.length && _.intersection(properties, operationProperties).length === properties.length && (postDataModel = modelName);
        }), postDataModel;
    }, this.envelopeNestedModel = function(modelName) {
        return Swagger.modelIsEnvelope(modelName) ? modelName.substr(modelName.substring(0, Swagger.envelopePrefixArray.length) === Swagger.envelopePrefixArray ? Swagger.envelopePrefixArray.length : Swagger.envelopePrefix.length) : modelName;
    }, this.nonEnvelopeModels = function(models) {
        var swagger = this, nonEnvelopeModels = {};
        return _.each(models, function(model, modelName) {
            swagger.modelIsEnvelope(modelName) || (nonEnvelopeModels[modelName] = model);
        }), nonEnvelopeModels;
    }, this.pathSections = function(path) {
        var regex = /^\/[a-zA-Z_-]*$/, regexParent = /[a-zA-Z_-]*\//, regexChild = /\/[a-zA-Z_-]*$/, simpleType = regex.test(path);
        if (simpleType) return {
            type: Swagger.pathTypes.parent,
            parent: path.substring(1),
            child: ""
        };
        regex = /^\/[a-zA-Z_-]+\/\{id\}$/;
        var idType = regex.test(path);
        if (idType) return {
            type: Swagger.pathTypes.parentId,
            parent: path.substring(1).match(regexParent)[0].slice(0, -1),
            child: ""
        };
        regex = /^\/[a-zA-Z_-]+\/\{id\}\/[a-zA-Z_-]+$/;
        var subMethodType = regex.test(path);
        if (subMethodType) return {
            type: Swagger.pathTypes.parentIdChild,
            parent: path.substring(1).match(regexParent)[0].slice(0, -1),
            child: path.match(regexChild)[0].substring(1)
        };
        regex = /^\/[a-zA-Z_-]+\/[a-zA-Z_-]+$/;
        var parentMethodType = regex.test(path);
        return parentMethodType ? {
            type: Swagger.pathTypes.parentChild,
            parent: path.substring(1).match(regexParent)[0].slice(0, -1),
            child: path.match(regexChild)[0].substring(1)
        } : {
            type: 0,
            parent: "",
            child: ""
        };
    }, this.getPathFromSections = function(type, parent, child) {
        var path = "/" + parent;
        return Swagger.pathTypeNeedsId(type) && (path += "/{id}"), Swagger.pathTypeNeedsChild(type) && (path += "/" + child), 
        Swagger.pathTypeNeedsChildId(type) && (path += "/{id}"), path;
    }, this.typesAndFormats = {
        string: [ "string", "string" ],
        date: [ "string", "date" ],
        "date-time": [ "string", "date-time" ],
        int32: [ "integer", "int32" ],
        int64: [ "integer", "int64" ],
        "float": [ "number", "float" ],
        "double": [ "number", "double" ],
        "boolean": [ "boolean", "boolean" ],
        "byte": [ "byte", "byte" ],
        "enum": [ "string", "string" ],
        object: [ "object", "object" ],
        "void": [ "void", "void" ]
    }, this.simpleTypes = [ "string", "integer", "number", "boolean", "byte", "void" ], 
    this.types = [ "string", "integer", "number", "boolean", "byte", "void", "array" ], 
    this.paramTypes = [ "path", "query", "header", "body", "form" ], this.reservedParamNames = [], 
    this.findOperationByPathAndMethod = function(apis, path, method) {
        var api = this.findApiByPath(apis, path);
        return this.findOperationByMethod(api, method);
    }, this.findApiByPath = function(apis, apiPath) {
        return _.find(apis, function(api) {
            return api.path === apiPath;
        });
    }, this.findOperationByMethod = function(api, method) {
        return _.find(api.operations, function(operation) {
            return operation.method === method;
        });
    }, this.findParameterByName = function(operation, parameterName) {
        var response = !1;
        return _.each(operation.parameters, function(parameter) {
            parameter.name === parameterName && (response = parameter);
        }), response;
    }, this.findModelIdProperty = function(model) {
        if (model.idProperty && model.properties[model.idProperty]) return model.properties[model.idProperty];
        if (model.mainParam && model.properties[model.mainParam]) return model.properties[model.mainParam];
        var idProperty = _.find(model.properties, function(property) {
            return property.isId || property.main;
        });
        if (!idProperty) throw new Error("id property not found in '" + model.id + "' model.");
        return idProperty;
    }, this.findIdInResponse = function(models, model, response, depth) {
        if (!models || !model || !response) throw new Error("Not all parameters were valid");
        if (depth || (depth = 1), depth > 4) throw new Error("Too much recursion");
        var idProperty = this.findModelIdProperty(model);
        if (!idProperty) throw new Error("Id property not found in model");
        if (!model.id) throw new Error("Model should have 'id' property");
        if (Swagger.modelIsEnvelope(model.id)) {
            if (idProperty.items && idProperty.items.$ref) {
                if (!_.isArray(response[idProperty.name])) throw new Error("Expected array in response");
                return this.findIdInResponse(models, this.getModelByName(models, idProperty.items.$ref), _.first(response[idProperty.name]), depth++);
            }
            if (idProperty.$ref) {
                if (!response[idProperty.name]) throw new Error("Id property not found in response");
                return this.findIdInResponse(models, this.getModelByName(models, idProperty.$ref), response[idProperty.name], depth++);
            }
            if (!response[idProperty.name]) throw new Error("Id property not found in response");
            return response[idProperty.name];
        }
        if (!response[idProperty.name]) throw new Error("Id property not found in response");
        return response[idProperty.name];
    }, this.supportedRequestTypes = function(apiMethod) {
        var methods = [];
        return _.each(apiMethod.operations, function(operation) {
            methods.push(operation.method);
        }), methods;
    }, this.prepSwagger = function(json) {
        var swagger = this;
        json.prepped = !0, json.envelopeIsUsed = !1, swagger.inferPostModels(json.apis, json.models), 
        swagger.prepModels(json.models), _.each(json.apis, function(api) {
            swagger.prepApi(api), _.each(api.operations, function(operation) {
                swagger.prepOperation(operation, api, json), api.hidden = api.hidden || operation.hidden, 
                api.disabled = api.disabled || operation.disabled, api.operationMethods.push(operation.method), 
                api.supports[operation.method] = !0, json.envelopeIsUsed = json.envelopeIsUsed || operation.usesEnvelope;
            }), api.operations = Utility.arrayToMap(api.operations, "method"), api.parentModel && json.models[api.parentModel] && (api.parentModelIdProperty = json.models[api.parentModel].idProperty);
        }), json.apis = Utility.arrayToMap(json.apis, "path"), json.envelope = swagger.inferEnvelope(json, json.models), 
        _.each(json.envelope.properties, function(property, propertyName) {
            property.name = propertyName, swagger.prepType(property), property.main && (json.envelope.mainParam = propertyName);
        }), _.each(json.parameters, function(parameter) {
            swagger.prepType(parameter);
        });
    }, this.prepApi = function(api) {
        api.hidden = !1, api.disabled = !1, api.operationMethods = [];
        var pathSections = this.pathSections(api.path);
        api.type = pathSections.type, api.parent = pathSections.parent, api.child = pathSections.child, 
        api.pathUsesId = Swagger.pathTypeNeedsId(api.type), api.pathUsesChild = Swagger.pathTypeNeedsChild(api.type), 
        api.pathUsesChildId = Swagger.pathTypeNeedsChildId(api.type), api.supports = {};
    }, this.prepLegacy = function(json) {
        Utility.log("Prep legacy");
        var apiDesigner = new ApiDesigner(), swagger = this;
        if (json.models.push) throw new Error("json.models should not be an array by this point.");
        json.envelope || (json.envelope = {
            mainParam: "",
            properties: []
        }), _.each(json.envelope.properties, function(property) {
            property.usedInResponses = !0, "undefined" == typeof property.expectedInResponses && (property.expectedInResponses = !1), 
            property.usedInPuts = !1, property.usedInPosts = !1;
        });
        var errorSet = !1, errorIndex = !1;
        _.each(json.models, function(model, modelIdx) {
            if (!_.size(model.properties)) {
                var property = apiDesigner.blankProperty();
                property.name = "id", property.description = "The id.", property.isId = !0, model.properties.id = property;
            }
            var idSet = !1, idIndex = !1, firstIndex = !1;
            _.each(model.properties, function(property, index) {
                swagger.simpleTypes.indexOf(property.type) >= 0 && delete property.$ref, firstIndex = firstIndex === !1 ? index : firstIndex, 
                idSet = idSet || "undefined" != typeof property.isId, (property.isId || "id" === property.name) && (idIndex = index), 
                "undefined" == typeof property.usedInResponses && (property.usedInResponses = !0), 
                "undefined" == typeof property.expectedInResponses && (property.expectedInResponses = !1), 
                "undefined" == typeof property.usedInPuts && (property.usedInPuts = !0), "undefined" == typeof property.usedInPosts && (property.usedInPosts = !0), 
                swagger.modelIsEnvelope(model.name) && (property.usedInPuts = !1, property.usedInPosts = !1), 
                swagger.prepLegacyType(property, json), delete property.responsesOnly, delete property.requestsOnly;
            }), idSet || (idIndex ? model.properties[idIndex].isId = !0 : model.properties[firstIndex].isId = !0), 
            errorSet = errorSet || "undefined" != typeof model.isError, (model.isError || "error" === model.name) && (errorIndex = modelIdx);
        }), errorSet || (errorIndex ? json.models[errorIndex].isError = !0 : json.models.error = apiDesigner.defaultModels.error), 
        _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                delete operation.undefined, swagger.prepLegacyType(operation, json), swagger.typesAndFormats[operation.type] || operation.$ref || !json.models[operation.type] || (operation.$ref = operation.type), 
                operation.$ref && operation.$ref === operation.type && delete operation.format, 
                _.each(operation.parameters, function(parameter) {
                    swagger.prepLegacyType(parameter, json);
                });
            });
        }), json.parameters || (json.parameters = []), _.each(json.parameters, function(parameter) {
            swagger.prepLegacyType(parameter, json);
        }), json.responseHeaders || (json.responseHeaders = apiDesigner.defaultResponseHeaders), 
        swagger.prepLegacyInfo(json), swagger.prepLegacyAuth(json);
    }, this.prepLegacyType = function(parameter, json) {
        var swagger = this;
        "integer" === parameter.type && parameter.example && parseInt(parameter.example) && (parameter.example = parseInt(parameter.example)), 
        "enum" === parameter.type && (parameter.type = "string"), swagger.typesAndFormats[parameter.type] && !_.contains(swagger.simpleTypes, parameter.type) && (parameter.format = parameter.type, 
        parameter.type = swagger.typesAndFormats[parameter.type][0]), !_.contains(swagger.simpleTypes, parameter.type) && json.models[parameter.type] && (parameter.$ref = parameter.type);
    }, this.prepLegacyInfo = function(json) {
        if (!json.info) {
            var apiDesigner = new ApiDesigner();
            json.info = apiDesigner.defaultInfo;
        }
        json.name && (json.info.title = json.name, delete json.name), json.description && (json.info.description = json.description, 
        delete json.description), json.contact && (json.info.contact = json.contact, delete json.contact);
    }, this.prepLegacyAuth = function(json) {
        if (!json.authorizations) {
            var apiDesigner = new ApiDesigner();
            json.authorizations = apiDesigner.defaultAuthorizations;
        }
        json.authRedirect && (json.authorizations.supports.oauth2Implicit = !0, json.authorizations.oauth2.grantTypes.implicit.loginEndpoint.url = json.authRedirect, 
        delete json.authRedirect), json.authParameter && (json.authorizations.oauth2.grantTypes.implicit.tokenName = json.authParameter, 
        delete json.authParameter);
    }, this.prepLegacyApi = function(json) {
        if (!json.prepped) throw new Error("Cannot prepLegacy Apis until json is prepped");
        var swagger = this;
        _.each(json.apis, function(api) {
            if (!api.parentModel) {
                if (api.child) {
                    var parentApi;
                    return json.apis["/" + api.parent] ? (parentApi = json.apis["/" + api.parent], api.parentModel = swagger.prepInferParentModel(parentApi), 
                    Utility.log(parentApi.path + " " + api.parentModel)) : json.apis["/" + api.parent + "/{id}"] ? (parentApi = json.apis["/" + api.parent + "/{id}"], 
                    api.parentModel = swagger.prepInferParentModel(parentApi)) : Utility.log("Counld not find /" + api.parent + " or /" + api.parent + "/{id}"), 
                    void (api.parentModel || Utility.log("Could not find a parent for " + api.path));
                }
                api.parentModel = swagger.prepInferParentModel(api);
            }
        });
    }, this.prepInferParentModel = function(api) {
        var parentModel, swagger = this;
        return api.parentModel ? api.parentModel : (_.each(api.operations, function(operation) {
            "GET" === operation.method && operation.displayModel && (parentModel = operation.displayModel), 
            !api.parentModel && swagger.methodSupportsPostData(operation.method) && operation.postDataModel && (parentModel = operation.postDataModel);
        }), parentModel);
    }, this.prepOperation = function(operation, api, json) {
        var swagger = this;
        if (operation.arrayOptional = Swagger.pathSupportsArrayResponses(api.path), operation.requestPath = [], 
        operation.responsePath = [], operation.hasBody = swagger.methodSupportsPostData(operation.method), 
        Swagger.modelIsEnvelope(operation.type)) {
            var envelopeModel = json.models[operation.type], mainParam = !1;
            if (_.each(envelopeModel.properties, function(property) {
                property.name === envelopeModel.mainParam && (mainParam = property);
            }), !mainParam) throw new Error("Main property not found in model " + operation.type);
            operation.usesEnvelope = !0, swagger.prepType(operation, mainParam), operation.responsePath.push(operation.type);
        } else operation.usesEnvelope = !1, swagger.prepType(operation);
        if (!swagger.typesAndFormats[operation.displayType]) throw new Error("Invalid displayType: " + operation.displayType);
        if (_.each(operation.parameters, function(parameter) {
            swagger.prepParameter(parameter);
        }), operation.displayModel) {
            if (!json.models[operation.displayModel]) throw new Error(operation.displayModel + " response model not found.");
            operation.responseIdProperty = json.models[operation.displayModel].idProperty, operation.responsePath.push(operation.displayModel);
        }
        if (operation.postDataModel) {
            if (!json.models[operation.postDataModel]) throw new Error(operation.postDataModel + " post data model not found.");
            operation.requestIdProperty = json.models[operation.postDataModel].idProperty, operation.requestPath.push(operation.postDataModel);
        }
        operation.responsePhrase = "Returns" + (operation.usesEnvelope ? " standard response envelope containing" : "") + (operation.isArray ? " array of " : " a ") + ("object" === operation.displayType ? "'" + operation.displayModel + "' model" : operation.displayType) + (operation.isArray ? "s" : "") + ".";
    }, this.prepModels = function(models) {
        var swagger = this;
        _.each(models, function(model, modelName) {
            model.id = modelName, swagger.prepModel(model);
        });
    }, this.prepParameter = function(parameter) {
        var swagger = this;
        swagger.prepType(parameter);
    }, this.prepModel = function(model) {
        if (model.properties instanceof Array) throw new Error("model.properties should be an object at this point");
        var swagger = this;
        model.properties = Utility.mapToArray(model.properties, "name"), model.isEnvelope = Swagger.modelIsEnvelope(model.id), 
        _.each(model.properties, function(property) {
            property.arrayOptional = !0, swagger.prepType(property), property.required = model.required ? model.required.indexOf(property.name) >= 0 : !1, 
            property.isId && (model.idProperty = property.name);
        }), model.idProperty || (model.properties.length && (model.idProperty = model.properties[0].name, 
        model.properties[0].isId = !0), Utility.log("Chose arbitrary id for " + model.id + " model."));
    }, this.prepType = function(object, typeObject) {
        var swagger = this;
        if (typeObject || (typeObject = object), object.isArray = !1, "array" === typeObject.type) {
            if (!typeObject.items) throw Utility.log(typeObject), new Error("Array type but no items!");
            object.isDictionary || (object.isArray = !0);
        }
        if ("array" === object.type || object.isArray || object.isDictionary) if (typeObject.items.$ref) object.displayType = "object", 
        object.displayModel = typeObject.items.$ref; else {
            if (!typeObject.items.type) throw new Error("Bad array type.");
            object.displayType = typeObject["enum"] ? "enum" : typeObject.items.format || typeObject.items.type;
        } else if (_.contains(swagger.simpleTypes, typeObject.type)) object.displayType = typeObject["enum"] ? "enum" : typeObject.format || typeObject.type; else if (typeObject.$ref) object.displayType = "object", 
        object.displayModel = typeObject.$ref; else if (!typeObject.main) throw Utility.log(typeObject), 
        new Error("Bad type: " + typeObject.name + " - " + typeObject.description);
        if ("enum" !== object.displayType || object["enum"] || (object["enum"] = []), !object.displayType && !typeObject.main) throw Utility.log(typeObject), 
        new Error("typeObject " + typeObject.name + " should have a displayType by now");
    }, this.prepDesigner = function(json) {
        _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                operation.parameters = _.filter(operation.parameters, function(parameter) {
                    return "query" === parameter.paramType || "header" === parameter.paramType || "path" === parameter.paramType;
                });
            });
        }), _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                operation.parameters = _.filter(operation.parameters, function(parameter) {
                    return !parameter.global && "path" !== parameter.paramType;
                });
            });
        });
    }, this.prepDocs = function(json) {
        var swagger = this;
        _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                operation.requestUrl = json.basePath + api.path + "?", operation.requestData = "";
                var params = {
                    path: {},
                    query: {},
                    header: {},
                    body: {},
                    form: {}
                };
                _.each(operation.parameters, function(parameter) {
                    params[parameter.paramType][parameter.name] = parameter.isArray ? parameter.example || 0 === parameter.example ? '["' + parameter.example + '"]' : parameter["enum"] && parameter["enum"].length ? '["' + parameter["enum"][0] + '"]' : swagger.displayDefaults[parameter.format] ? '["' + swagger.displayDefaults[parameter.format] + '"]' : '["example"]' : parameter.example || 0 === parameter.example ? parameter.example : parameter["enum"] && parameter["enum"].length ? parameter["enum"][0] : swagger.displayDefaults[parameter.format] ? swagger.displayDefaults[parameter.format] : "example";
                }), operation.requiresAuth && (operation.requestUrl += (json.authParameter ? json.authParameter : "access_token") + "=123456789&"), 
                _.size(params.query) && (operation.requestQuery = swagger.parameterString(params.query)), 
                _.size(params.body) && (operation.requestData = swagger.parameterString(params.body));
            });
        }), swagger.prepResponses(json, !1), swagger.prepRequests(json);
    }, this.prepRequests = function(json) {
        var swagger = this;
        _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                swagger.methodSupportsPostData(operation.method) && (operation.requestJson = swagger.operationRequestJson(json.models, operation, !1));
            });
        });
    }, this.prepResponses = function(json, omitErrors) {
        var swagger = this;
        _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                operation.responseJson = swagger.modelResponseJson(json.models, operation, !0, omitErrors);
            });
        });
    }, this.prepSDK = function(json) {
        if (!json.resources) throw new Error("json should contain resources information.");
        _.each(json.resources, function(resource, resourceName) {
            resource.idApi = {}, json.apis["/" + resourceName + "/{id}"] && (resource.idApi = json.apis["/" + resourceName + "/{id}"]), 
            resource.listApi = {}, json.apis["/" + resourceName] && (resource.listApi = json.apis["/" + resourceName]), 
            resource.childApis = {}, _.each(resource.children, function(childMethods, childName) {
                resource.childApis[childName] = json.apis["/" + resourceName + "/{id}/" + childName];
            }), resource.parentApis = {}, _.each(resource.parents, function(parentMethods, parentName) {
                resource.parentApis[parentName] = json.apis["/" + parentName + "/{id}/" + resourceName];
            }), resource.actionApis = {}, _.each(resource.actions, function(methods, action) {
                resource.actionApis[action] = json.apis["/" + resourceName + "/" + action];
            });
        });
    }, this.resourceRelationships = function(json) {
        var swagger = this, resources = {};
        return _.each(json.apis, function(api) {
            var sections = swagger.pathSections(api.path);
            if (!sections.parent) throw new Error("Api '" + api.path + "' should have a parent");
            resources[sections.parent] || (resources[sections.parent] = {
                idOperations: [],
                listOperation: [],
                parents: {},
                children: {},
                actions: {}
            }), sections.child && (resources[sections.child] || (resources[sections.child] = {
                idOperations: [],
                listOperation: [],
                parents: {},
                children: {},
                actions: {}
            }));
            var operationParamCounts = {};
            _.each(api.operations, function(operation) {
                operationParamCounts[operation.method] = {
                    params: 0,
                    data: 0,
                    headers: 0,
                    exampleResponse: operation.responseJson
                };
                var paramCounts = operationParamCounts[operation.method];
                _.each(operation.parameters, function(parameter) {
                    switch (parameter.paramType) {
                      case "path":
                        break;

                      case "query":
                        paramCounts.params++;
                        break;

                      case "header":
                        paramCounts.headers++;
                        break;

                      case "body":
                        paramCounts.data++;
                        break;

                      case "form":
                        paramCounts.data++;
                    }
                }), paramCounts.functionParams = [], paramCounts.params && paramCounts.functionParams.push("params"), 
                (paramCounts.data || paramCounts.form) && paramCounts.functionParams.push("data"), 
                paramCounts.headers && paramCounts.functionParams.push("headers"), paramCounts.functionParams = (paramCounts.functionParams.length && Swagger.pathTypeNeedsId(sections.type) ? ", " : "") + paramCounts.functionParams.join(", ");
            }), 1 === sections.type ? resources[sections.parent].listOperations = operationParamCounts : 2 === sections.type ? resources[sections.parent].idOperations = operationParamCounts : 3 === sections.type ? (resources[sections.parent].children[sections.child] = operationParamCounts, 
            resources[sections.child].parents[sections.parent] = operationParamCounts) : 4 === sections.type && (resources[sections.parent].actions[sections.child] = operationParamCounts);
        }), resources;
    }, this.flattenModels = function(models) {
        var swagger = this;
        _.each(models, function(model) {
            swagger.flattenModel(model, models, 1);
        });
    }, this.flattenModel = function(model, models, depth, path) {
        var newPath;
        if (path || (path = []), !_.contains(path, model.id)) {
            if (newPath = angular.copy(path), newPath.push(model.id), depth > 10) throw new Error("Exceeded maximum model depth, " + newPath.join(", "));
            var swagger = this;
            _.each(model.properties, function(property) {
                property.$ref ? (property.model = _.extend({}, models[property.$ref]), swagger.flattenModel(property.model, models, depth + 1, newPath)) : property.items && property.items.$ref && (property.model = _.extend({}, models[property.items.$ref]), 
                swagger.flattenModel(property.model, models, depth + 1, newPath)), property["enum"] && property["enum"].length && !property.example && (property.example = property["enum"][0]);
            });
        }
    }, this.convertExpectationsToObject = function(expectations) {
        var data = {};
        return _.each(expectations, function(expectation) {
            for (var pathSoFar = data, i = 0; i < expectation.path.length; i++) {
                var key = expectation.path[i];
                if (i === expectation.path.length - 1) pathSoFar[key] = expectation.value; else {
                    if (!pathSoFar[key]) {
                        var nextKey = expectation.path[i + 1];
                        if ("number" == typeof nextKey) {
                            if (0 !== nextKey) throw new Error("We only currently support single entry, 0 indexed arrays");
                            pathSoFar[key] = [];
                        } else pathSoFar[key] = {};
                    }
                    pathSoFar = pathSoFar[key];
                }
            }
        }), data;
    }, this.postProcess = function(json) {
        if (!json.prepped) throw new Error("Can only process JSON that has been prepped.");
        var swagger = this;
        delete json.prepped, swagger.updateTypesUsingDisplayTypes(json), _.each(json.envelope.properties, function(property) {
            property.main && (json.envelope.mainParam = property.name);
        }), _.each(json.apis, function(api) {
            api.path = swagger.getPathFromSections(api.type, api.parent, api.child), delete api.hidden, 
            delete api.disabled, delete api.operationMethods, delete api.supports, delete api.type, 
            delete api.parent, delete api.child, delete api.pathUsesId, delete api.pathUsesChild, 
            delete api.parentModelIdProperty, _.each(api.operations, function(operation) {
                if (operation.usesEnvelope && swagger.createEnvelopeModel(operation, json.envelope, json.models), 
                (operation.$ref || operation.items) && delete operation.format, operation.$ref && swagger.typesAndFormats[operation.$ref]) throw new Error("operation.$ref '" + operation.$ref + "' should not be a simple type.");
                delete operation.responsePhrase, delete operation.responseIdProperty, delete operation.requestIdProperty, 
                delete operation.responsePath, delete operation.requestPath, delete operation.hasBody;
            }), api.operations = Utility.mapToArray(api.operations, "method");
        }), _.each(json.models, function(model) {
            model.required = [], _.each(model.properties, function(property) {
                property.required && model.required.push(property.name);
            }), delete model.idProperty, model.properties = Utility.arrayToMap(model.properties, "name");
        }), json.envelope.properties = Utility.arrayToMap(json.envelope.properties, "name"), 
        _.each(json.envelope.properties, function(property, propertyName) {
            property.main && (json.envelope.mainParam = propertyName);
        }), swagger.removeDisplayProperties(json);
    }, this.updateTypesUsingDisplayTypes = function(json) {
        var swagger = this;
        _.each(json.parameters, function(parameter) {
            swagger.displayTypesToSwaggerTypes(parameter);
        }), _.each(json.envelope.properties, function() {}), _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                swagger.displayTypesToSwaggerTypes(operation), _.each(operation.parameters, function(parameter) {
                    swagger.displayTypesToSwaggerTypes(parameter);
                });
            });
        }), _.each(json.models, function(model) {
            _.each(model.properties, function(property) {
                swagger.modelIsEnvelope(model.name) || swagger.displayTypesToSwaggerTypes(property);
            });
        });
    }, this.removeDisplayProperties = function(json) {
        var swagger = this;
        _.each(json.parameters, function(parameter) {
            swagger.removeDisplayTypeValues(parameter);
        }), _.each(json.envelope.properties, function(property) {
            swagger.removeDisplayTypeValues(property);
        }), _.each(json.apis, function(api) {
            _.each(api.operations, function(operation) {
                swagger.removeDisplayTypeValues(operation), _.each(operation.parameters, function(parameter) {
                    swagger.removeDisplayTypeValues(parameter);
                });
            });
        }), _.each(json.models, function(model) {
            _.each(model.properties, function(property) {
                swagger.removeDisplayTypeValues(property);
            });
        });
    }, this.displayTypesToSwaggerTypes = function(operation, typeObject, forEnvelopeParam) {
        if (typeObject || (typeObject = operation), !this.typesAndFormats[typeObject.displayType]) throw new Error("Invalid displayType: " + typeObject.displayType);
        if ("object" === typeObject.displayType) {
            if (delete operation.format, !typeObject.displayModel) throw Utility.log(operation), 
            new Error("typeObject is object type but has no displayModel");
            typeObject.isArray || typeObject.isDictionary ? (typeObject.usesEnvelope && !forEnvelopeParam ? (operation.type = "array", 
            operation.items = {}, operation.items.type = this.getModelEnvelopeName(typeObject.displayModel, typeObject.isArray, typeObject.isDictionary), 
            operation.items.$ref = typeObject.type) : (operation.type = "array", operation.items = {}, 
            operation.items.type = typeObject.displayModel, operation.items.$ref = typeObject.displayModel), 
            typeObject.isDictionary && (operation.isDictionary = !0)) : typeObject.usesEnvelope && !forEnvelopeParam ? (operation.type = this.getModelEnvelopeName(typeObject.displayModel, typeObject.isArray, typeObject.isDictionary), 
            operation.$ref = typeObject.type) : (operation.type = typeObject.displayModel, operation.$ref = typeObject.displayModel);
        } else {
            if (!typeObject.displayType) throw Utility.log(operation), Utility.log(typeObject), 
            new Error("typeObject should have a displayType");
            typeObject.isArray || typeObject.isDictionary ? (typeObject.usesEnvelope && !forEnvelopeParam ? (operation.type = "array", 
            operation.items = {}, operation.items.type = this.getTypeEnvelope(typeObject.displayType, typeObject.isArray, typeObject.isDictionary), 
            operation.items.$ref = typeObject.type) : (operation.type = "array", operation.items = {}, 
            operation.items.type = this.getTypeFromFormat(typeObject.displayType), operation.items.format = "enum" === typeObject.displayType ? "string" : typeObject.displayType), 
            typeObject.isDictionary && (operation.isDictionary = !0)) : typeObject.usesEnvelope && !forEnvelopeParam ? (operation.type = this.getTypeEnvelope(typeObject.displayType, typeObject.isArray, typeObject.isDictionary), 
            operation.$ref = typeObject.type) : (operation.type = this.getTypeFromFormat(typeObject.displayType), 
            operation.format = "enum" === typeObject.displayType ? "string" : typeObject.displayType, 
            delete operation.$ref);
        }
        if ("enum" === operation.type) throw new Error("'enum' is not a valid type.");
        if ("enum" === operation.format) throw new Error("'enum' is not a valid type.");
    }, this.removeDisplayTypeValues = function(typeObject) {
        ("object" === typeObject.displayType || "void" === typeObject.displayType) && delete typeObject.example, 
        "array" === typeObject.type || typeObject.isDictionary ? delete typeObject.$ref : delete typeObject.items, 
        delete typeObject.displayType, delete typeObject.displayModel, delete typeObject.actualModel, 
        delete typeObject.isArray, delete typeObject.usesEnvelope, delete typeObject.arrayOptional, 
        (!typeObject["enum"] || typeObject["enum"] instanceof Array && !typeObject["enum"].length) && delete typeObject["enum"];
    }, this.removeModelPropertiesBasedOnUsage = function(model, method, isResponse) {
        var swagger = this, propertiesToRemove = [];
        _.each(model.properties, function(property, propertyName) {
            isResponse ? property.usedInResponses || propertiesToRemove.push(propertyName) : "POST" !== method || property.usedInPosts ? swagger.methodIsUpdate(method) && !property.usedInPuts && propertiesToRemove.push(propertyName) : propertiesToRemove.push(propertyName), 
            property.model && swagger.removeModelPropertiesBasedOnUsage(property.model, method, isResponse);
        }), _.each(propertiesToRemove, function(propertyToRemove) {
            delete model.properties[propertyToRemove];
        });
    }, this.getTypeFromFormat = function(format) {
        if (!format || !this.typesAndFormats[format]) throw new Error(format + " is an unknown format.");
        return this.typesAndFormats[format][0];
    }, this.getOperationByPathAndMethod = function(apis, path, method) {
        if (!apis[path] || !apis[path].operations[method]) throw new Error(method + " " + path + " path not found in apis");
        return apis[path].operations[method];
    }, this.getModelByName = function(models, modelName) {
        var returnModel = !1;
        return models instanceof Array ? _.each(models, function(model) {
            model.name === modelName && (returnModel = model);
        }) : models[modelName] && (returnModel = models[modelName]), returnModel;
    }, this.getModelByResponseType = function(operation, models, responseMessages, responseCode) {
        var modelName = !1, responseType = !1;
        if (responseCode || (responseCode = 200), _.isArray(operation.responseMessages) && (responseType = _.find(operation.responseMessages, function(responseType) {
            return responseType.code === responseCode;
        })), !responseType && _.isArray(operation.responseMessages) && (responseType = _.find(responseMessages, function(responseType) {
            return responseType.code === responseCode;
        })), responseType && responseType.responseModel) modelName = responseType.responseModel; else if (operation.$ref) modelName = operation.$ref; else {
            if (!operation.items || !operation.items.$ref) throw new Error(operation.items && operation.items.type ? "Not implemented." : operation.type ? "Not implemented." : "Unrecognised type.");
            modelName = operation.items.$ref;
        }
        return Utility.log("Copying model: " + modelName), this.getModelByName(models, modelName);
    }, this.modelIsEnvelope = function(modelName) {
        return Swagger.modelIsEnvelope(modelName);
    }, this.getModelIdByName = function(models, modelName) {
        var model = this.getModelByName(models, modelName);
        if (model) {
            var property = this.findModelIdProperty(model);
            return property.name;
        }
        throw new Error("Model '" + modelName + "' not found");
    }, this.getModelEnvelopeName = function(modelName, isArray, isDictionary, isPaged) {
        if (Swagger.modelIsEnvelope(modelName)) throw new Error("Should not be trying to get envelope version of an envelope");
        return isDictionary && !isPaged ? Swagger.envelopePrefixDictionary + modelName : isDictionary && isPaged ? Swagger.envelopePrefixDictionaryPaged + modelName : isArray && !isPaged ? Swagger.envelopePrefixArray + modelName : isArray && isPaged ? Swagger.envelopePrefixArrayPaged + modelName : isPaged ? Swagger.envelopePrefixPaged + modelName : Swagger.envelopePrefix + modelName;
    }, this.getTypeEnvelope = function(simpleType, isArray, isDictionary) {
        return this.getModelEnvelopeName(simpleType, isArray, isDictionary);
    }, this.apisUsingModel = function(modelName) {
        var apis = [];
        return _.each($("#apis .models:enabled"), function(modelSelect) {
            $(modelSelect).val() === modelName && apis.push($(modelSelect).parents(".api").find(".api-path").val());
        }), _.uniq(apis);
    }, this.modelsUsingModel = function() {
        var models = [];
        return _.uniq(models);
    }, this.parameterString = function(keyValues) {
        var queryParams = [];
        return _.each(keyValues, function(value, key) {
            queryParams.push(key + "=" + value);
        }), queryParams.join("&");
    }, this.buildExpectationsFromModelExamples = function(expectations, pathSoFar, model) {
        var swagger = this;
        _.each(model.properties, function(property) {
            var newPathsSoFar = _.clone(pathSoFar);
            if (property.model) newPathsSoFar.push(property.name), property.items && newPathsSoFar.push(0), 
            swagger.buildExpectationsFromModelExamples(expectations, newPathsSoFar, property.model); else if (property.expectedInResponses) if (newPathsSoFar.push(property.name), 
            property.example) if (_.isArray(property.example)) {
                if (!property.items || !property.items.type) throw new Error("Should only have an example of simple type");
                expectations.push({
                    path: newPathsSoFar,
                    value: _.map(property.example, function(iterator) {
                        switch (property.items.type) {
                          case "integer":
                            return parseInt(iterator);

                          case "number":
                            return Number(iterator);

                          case "bit":
                            return iterator ? 1 : 0;

                          default:
                            return iterator;
                        }
                    })
                });
            } else expectations.push({
                path: newPathsSoFar,
                value: property.example
            }); else expectations.push({
                path: newPathsSoFar
            });
        });
    }, this.displayDefaults = {
        string: "example",
        date: "2014-06-10",
        "date-time": "2014-06-10T12:34:56",
        int32: 12345,
        int64: 1234567890,
        "float": 12.34,
        "double": 12.34,
        "boolean": !0,
        "byte": 1,
        "void": ""
    }, this.modelResponseJson = function(models, operation, format, omitError) {
        var json = {}, requestType = !1, path = [];
        if (operation.$ref || operation.usesEnvelope) {
            var envelopeModel = models[operation.$ref];
            if (!envelopeModel) throw new Error(operation.$ref + " not found in models collection!");
            path.push(operation.$ref), json = this.modelExampleJson(models, envelopeModel, 1, omitError, requestType, operation.isPaged, path);
        } else json = this.fieldExampleJson(models, operation, 1, requestType, path);
        return format ? JSON.stringify(json, null, 4) : json;
    }, this.operationRequestJson = function(models, operation, format) {
        var json = {}, path = [];
        if (operation.postDataModel) {
            var model = models[operation.postDataModel];
            if (!model) throw new Error(operation.postDataModel + " not found in models collection!");
            path.push(operation.postDataModel), json = this.modelExampleJson(models, model, 1, !0, operation.method, !1, path);
        }
        return format ? JSON.stringify(json, null, 4) : json;
    }, this.modelExampleJson = function(models, model, depth, omitError, requestType, isPaged, path) {
        if (depth > 10) return "...";
        var json = {}, swagger = this;
        return _.each(model.properties, function(property) {
            if (!property.type && !property.$ref) throw new Error("The '" + property.name + "' property in the '" + type + "' model has no type!");
            omitError && property.$ref && models[property.$ref] && models[property.$ref].isError || "void" !== property.type && !(swagger.methodIsUpdate(requestType) && !property.usedInPuts || "POST" === requestType && !property.usedInPosts || !requestType && _.has(property, "usedInResponses") && !property.usedInResponses || property.pagedOnly && !isPaged || !(swagger.methodSupportsPostData(requestType) && model.onlyIdsForNestedPosts && !property.isId || (json[property.name] = swagger.fieldExampleJson(models, property, depth, requestType, path))));
        }), json;
    }, this.fieldExampleJson = function(models, property, depth, requestType, path) {
        var pathClone = _.clone(path);
        return property.isDictionary ? this.dictionaryExampleJson(models, property, depth, requestType, pathClone) : property.isArray ? this.arrayExampleJson(models, property, depth, requestType, pathClone) : this.singleExampleJson(models, property, depth, requestType, pathClone);
    }, this.dictionaryExampleJson = function(models, property, depth, requestType, path) {
        var nestedModel;
        return property.example ? {
            example: this.formatNumber(property.items.type, property.example)
        } : "object" === property.displayType ? (nestedModel = models[property.displayModel]) ? this.containsRecursion(path, property.displayModel) ? "..." : (path.push(property.displayModel), 
        {
            example: this.modelExampleJson(models, nestedModel, depth + 1, !1, requestType, !1, path)
        }) : {
            example: "Model not found"
        } : property.items && property.items.$ref ? (nestedModel = models[property.items.$ref]) ? this.containsRecursion(path, property.items.$ref) ? "..." : (path.push(property.items.$ref), 
        {
            example: this.modelExampleJson(models, nestedModel, depth + 1, !1, requestType, !1, path)
        }) : {
            example: "Model not found"
        } : "enum" === property.displayType && property["enum"] && property["enum"].length ? {
            example: property["enum"][0]
        } : this.displayDefaults.hasOwnProperty(property.displayType) ? {
            example: this.displayDefaults[property.displayType]
        } : {
            example: "Type not found"
        };
    }, this.arrayExampleJson = function(models, property, depth, requestType, path) {
        var nestedModel;
        return property.example ? [ this.formatNumber(property.items.type, property.example) ] : "object" === property.displayType ? (nestedModel = models[property.displayModel]) ? this.containsRecursion(path, property.displayModel) ? [ "..." ] : (path.push(property.displayModel), 
        [ this.modelExampleJson(models, nestedModel, depth + 1, !1, requestType, !1, path) ]) : [ "Model not found" ] : property.items && property.items.$ref ? (nestedModel = models[property.items.$ref]) ? this.containsRecursion(path, property.items.$ref) ? [ "..." ] : (path.push(property.items.$ref), 
        [ this.modelExampleJson(models, nestedModel, depth + 1, !1, requestType, !1, path) ]) : [ "Model not found" ] : "enum" === property.displayType && property["enum"] && property["enum"].length ? [ property["enum"][0] ] : this.displayDefaults.hasOwnProperty(property.displayType) ? property.example || "boolean" === property.displayType && void 0 !== property.example ? [ property.example ] : [ this.displayDefaults[property.displayType] ] : [ "Type not found" ];
    }, this.singleExampleJson = function(models, property, depth, requestType, path) {
        if (property.example || "boolean" === property.displayType && void 0 !== property.example) return this.formatNumber(property.type, property.example);
        if ("object" === property.displayType) {
            var nestedModel = models[property.displayModel];
            return nestedModel ? this.containsRecursion(path, property.displayModel) ? [ "..." ] : (path.push(property.displayModel), 
            this.modelExampleJson(models, nestedModel, depth + 1, !1, requestType, !1, path)) : "Model not found";
        }
        return "enum" === property.displayType && property["enum"] && property["enum"].length ? property["enum"][0] : this.displayDefaults.hasOwnProperty(property.displayType) ? this.displayDefaults[property.displayType] : "Type not found";
    }, this.containsRecursion = function(path, object) {
        var count = 0;
        return _.each(path, function(iter) {
            iter === object && count++;
        }), count > 1;
    }, this.formatNumber = function(type, string) {
        return "integer" === type || "number" === type ? +string : string;
    }, this.methods = [ "GET", "PUT", "POST", "PATCH", "DELETE", "HEAD" ], this.methodSupportsPostData = function(method) {
        return "PUT" === method || "POST" === method || "PATCH" === method;
    }, this.methodIsCreate = function(method) {
        return "POST" === method;
    }, this.methodIsUpdate = function(method) {
        return "PUT" === method || "PATCH" === method;
    }, this.pathTypeNeedsId = function(pathType) {
        return Swagger.pathTypeNeedsId(pathType);
    }, this.pathTypeNeedsChildId = function(pathType) {
        return Swagger.pathTypeNeedsChildId(pathType);
    }, this.pathTypeNeedsChild = function(pathType) {
        return Swagger.pathTypeNeedsChild(pathType);
    }, this.pathSupportsArrayResponses = function(path) {
        return Swagger.pathSupportsArrayResponses(path);
    }, this.modelIsEnvelope = function(modelName) {
        return Swagger.modelIsEnvelope(modelName);
    };
}

angular.module("apis-application.services").service("ApiDesigner", ApiDesigner), 
$(document).ready(function() {
    $("#save-method-button").on("click", function() {
        supportedMethods = _.map($(".new-method-supported:checked"), function(jEl) {
            return $(jEl).val();
        });
    });
}), angular.module("apis-application.services").service("ApiService2", [ "$q", ApiService2 ]), 
angular.module("apis-application.services").service("ApiService", [ "$window", "$http", "$q", "$routeParams", "AuthService", "ApiService2", ApiService ]), 
AuthService.setToken = function(token, expires_in) {
    var dateProvider = new Date(), now = Math.floor(dateProvider.getTime() / 1e3), sessionInfo = {
        token: token,
        expiresAt: now + expires_in - 5
    };
    return window.localStorage.token = JSON.stringify(sessionInfo), window.location = window.location, 
    token;
}, angular.module("apis-application.services").service("AuthService", [ "$window", "$http", AuthService ]), 
angular.module("apis-application.services").service("SwaggerDiff", [ "Utility", SwaggerDiff ]), 
function(angular) {
    function console_log(str) {
        console && console.log && console.log(str);
    }
    function SwaggerValidate() {
        this.camelCase = new RegExp(/^([a-z][a-zA-Z]*)*$/), this.camelCaseNumeric = new RegExp(/^([a-z][a-zA-Z0-9]*)*$/), 
        this.camelCaseNumericUnderscore = new RegExp(/^([a-z][a-zA-Z0-9_]*)*$/), this.validate = function(json) {
            var swaggerValidate = this;
            if (console_log("Validating swagger JSON methods: " + json.basePath), json.prepped) throw new Error("JSON should not be prepped when validating.");
            var errors = [];
            return swaggerValidate.validateMeta(errors, json), swaggerValidate.validateInfo(errors, json.info), 
            swaggerValidate.validateAuth(errors, json.authorizations), swaggerValidate.validateResponseMessages(errors, json.responseMessages), 
            swaggerValidate.validateEnsureArray(json.apis, "json.apis"), _.each(json.apis, function(method) {
                swaggerValidate.validateMethod(errors, json, method), swaggerValidate.validateEnsureArray(method.operations, "method.operations"), 
                _.each(method.operations, function(operation) {
                    swaggerValidate.validateOperation(errors, json, method, operation), swaggerValidate.validateEnsureArray(operation.parameters, "operation.parameters"), 
                    _.each(operation.parameters, function(parameter) {
                        swaggerValidate.validateParameter(errors, json, method, operation, parameter);
                    });
                    var parameterNames = _.map(operation.parameters, function(parameter) {
                        return parameter.name;
                    });
                    _.uniq(parameterNames).length !== operation.parameters.length && errors.push("Parameters have duplicate names in " + operation.method + " operation of " + method.path + " method.");
                });
            }), console_log("Validating swagger JSON models"), swaggerValidate.validateEnsureObject(json.models, "json.models"), 
            _.each(json.models, function(model, modelName) {
                swaggerValidate.validateModel(errors, json, model, modelName), swaggerValidate.validateEnsureObject(model.properties, "model.properties");
            }), console_log("Finished validating swagger"), errors;
        }, this.validateMeta = function(errors, json) {
            json.basePath || (console_log(json), errors.push("The API has no basePath.")), json.apiVersion || errors.push("The API has no version.");
        }, this.validateInfo = function() {}, this.validateResponseMessages = function() {}, 
        this.validateAuth = function(errors, authorizations) {
            authorizations.supports.oauth2Implicit && (authorizations.oauth2.grantTypes.implicit.tokenName || errors.push("The API has no auth parameter."), 
            this.camelCaseNumericUnderscore.test(authorizations.oauth2.grantTypes.implicit.tokenName) || errors.push("The API auth parameter is not camelCase.")), 
            authorizations.supports.oauth2AuthorizationCode && (authorizations.oauth2.grantTypes.authorization_code.tokenRequestEndpoint.url || errors.push("The API has no token request endpoint Url."), 
            authorizations.oauth2.grantTypes.authorization_code.tokenRequestEndpoint.clientIdName || errors.push("The API has no token request endpoint client ID parameter name."), 
            authorizations.oauth2.grantTypes.authorization_code.tokenRequestEndpoint.clientSecretName || errors.push("The API has no token request endpoint client secret parameter name."), 
            authorizations.oauth2.grantTypes.authorization_code.tokenEndpoint.url || errors.push("The API has no token endpoint url."), 
            authorizations.oauth2.grantTypes.authorization_code.tokenEndpoint.tokenName || errors.push("The API has no token endpoint token parameter name."));
        }, this.validateMethod = function(errors, json, method) {
            this.validatePath(errors, method.path), method.parentModel || -1 === method.path.indexOf("{") || errors.push("Method " + method.path + " has no parentModel");
        }, this.validateOperation = function(errors, json, method, operation) {
            var operationType = operation.type;
            operationType || operation.$ref || errors.push("No type declared for '" + operation.method + "' operation in '" + method.path + "' api"), 
            operation.type && operation.$ref && operation.format && errors.push("Can't have type and ref and format in " + operation.method + "' operation in '" + method.path + "' api"), 
            "array" === operationType ? operation.items ? operation.items.$ref ? operationType = operation.items.$ref : operation.items.type ? operationType = operation.items.type : errors.push("Type is Array but no array type declared for '" + operation.method + "' operation in '" + method.path + "' api") : errors.push("Type is Array but no array type declared for '" + operation.method + "' operation in '" + method.path + "' api") : operation.$ref && (json.models ? json.models[operation.$ref] || errors.push("The $ref '" + operation.$ref + "' declared for '" + operation.method + "' operation in '" + method.path + "' api could not be found in the models collection.") : errors.push("The $ref '" + operation.$ref + "' declared for '" + operation.method + "' operation in '" + method.path + "' api could not be found as it is not a simple type and there are no models.")), 
            operation.$ref && "array" === operationType && errors.push("Operation cannot be array type and have a $ref"), 
            operation.summary || errors.push("Method " + method.path + " has no summary for " + operation.method + " operation");
        }, this.validateParameter = function(errors, json, method, operation, parameter) {
            var swagger = new Swagger();
            operation.postDataModel && "body" === parameter.paramType || (_.contains(this.reservedParamNames, parameter.name) && ("id" === parameter.name && "path" === parameter.paramType || errors.push("In '" + method.path + "' '" + operation.method + "' '" + parameter.name + "' is a reserved parameter name.")), 
            parameter.name || errors.push("A parameter has no name in " + operation.method + " " + method.path + " method."), 
            _.contains(swagger.types, parameter.type) || json.models[parameter.type] || errors.push("Parameter '" + parameter.name + "' has type '" + parameter.type + "' which is not a simple type and is not a recognised model in " + operation.method + " " + method.path + " method."), 
            parameter.description || errors.push("A parameter has no description in " + operation.method + " " + method.path + " method."), 
            parameter.paramType || errors.push("In '" + method.path + "' '" + operation.method + "' no paramType for '" + parameter.name + "'"), 
            _.contains(swagger.paramTypes, parameter.paramType) || errors.push("In '" + method.path + "' '" + operation.method + "' paramType is not one of the allowed values: " + swagger.paramTypes.join(",")));
        }, this.validateModel = function(errors, json, model, modelName) {
            var swaggerValidate = this, swagger = new Swagger();
            if (!model.properties, angular.isArray(model.properties.push)) throw new Error("Model properties should not be an array at this point.");
            var idSet = !1;
            _.each(model.properties, function(property, propertyName) {
                swaggerValidate.validateProperty(errors, json, model, property, propertyName), idSet = idSet || "undefined" != typeof property.isId;
            }), idSet || swagger.modelIsEnvelope(modelName) || errors.push("The " + modelName + " model has no id.");
        }, this.validateModelRecursion = function(models) {
            var swaggerValidate = this, tooDeep = [];
            return _.each(models, function(model, modelName) {
                var path = [];
                path.push(modelName), swaggerValidate.modelRecursionCheck(models, model, modelName, 1, path) || tooDeep.push(modelName);
            }), tooDeep;
        }, this.modelRecursionCheck = function(models, model, modelName, depth, path) {
            if (depth > 3) return !1;
            var swaggerValidate = this, allGood = !0;
            return _.each(model.properties, function(property) {
                property.$ref && allGood && (path.push(property.$ref), allGood = allGood && swaggerValidate.modelRecursionCheck(models, models[property.$ref], property.$ref, depth + 1, path));
            }), allGood;
        }, this.validateProperty = function(errors, json, model, property, propertyName) {
            property.type || property.$ref || errors.push("The '" + propertyName + "' property in the '" + model.id + "' model has no type and is not a reference to a model.");
        }, this.validatePath = function(errors, path) {
            "/" !== path.substring(0, 1) && errors.push("API path '" + path + "' must begin with a '/'."), 
            "/" === path.slice(-1) && errors.push("API path '" + path + "' must not end with a '/'.");
            var regex = /[A-Z]/;
            regex = /^\/[a-zA-Z_-]*$/;
            var simpleType = regex.test(path);
            regex = /^\/[a-zA-Z_-]+\/\{id\}$/;
            var idType = regex.test(path);
            regex = /^\/[a-zA-Z_-]+\/\{id\}\/[a-zA-Z_-]+$/;
            var childResourceType = regex.test(path);
            regex = /^\/[a-zA-Z_-]+\/[a-zA-Z_-]+$/;
            var parentOperationType = regex.test(path);
            if (!(simpleType || idType || childResourceType || parentOperationType)) {
                regex = /^\/[a-z_-]+\/\{[a-z_-]+\}$/;
                var badParam = regex.test(api.path);
                regex = /^\/[a-z_-]+\/\{[a-z_-]+\}\/[a-z_-]+$/, badParam = badParam && regex.test(path), 
                errors.push(badParam ? "API path '" + path + "' can only contain a parameter named '{id}'." : "API path '" + path + "' does not match any of the allowed formats: '/parent', '/parent/{id}', '/parent/{id}/child' or '/parent/operation'");
            }
            return errors;
        }, this.validateEnsureArray = function(test, testedArray) {
            if (!_.isArray(test)) throw new Error(testedArray + " is not an array");
        }, this.validateEnsureObject = function(test, testedObject) {
            if (!_.isObject(test)) throw new Error(testedObject + " is not an object");
        };
    }
    angular.module("apis-application.services").service("SwaggerValidate", SwaggerValidate);
}(window.angular), Swagger.pathTypeNeedsId = function(pathType) {
    return parseInt(pathType) === Swagger.pathTypes.parentId || parseInt(pathType) === Swagger.pathTypes.parentIdChild;
}, Swagger.pathTypeNeedsChildId = function() {
    return !1;
}, Swagger.pathTypeNeedsChild = function(pathType) {
    return parseInt(pathType) === Swagger.pathTypes.parentIdChild || parseInt(pathType) === Swagger.pathTypes.parentChild;
}, Swagger.pathSupportsArrayResponses = function(path) {
    return path.split("/").length <= 2;
}, Swagger.pathTypes = {
    parent: 1,
    parentId: 2,
    parentIdChild: 3,
    parentChild: 4
}, Swagger.envelopePrefix = "env__", Swagger.envelopePrefixPaged = "penv__", Swagger.envelopePrefixArray = "aenv__", 
Swagger.envelopePrefixArrayPaged = "apenv__", Swagger.envelopePrefixDictionary = "denv__", 
Swagger.envelopePrefixDictionaryPaged = "dpenv__", Swagger.modelIsEnvelope = function(modelName) {
    return modelName && (modelName.envelope || modelName.substring(0, Swagger.envelopePrefix.length) === Swagger.envelopePrefix || modelName.substring(0, Swagger.envelopePrefixPaged.length) === Swagger.envelopePrefixPaged || modelName.substring(0, Swagger.envelopePrefixArray.length) === Swagger.envelopePrefixArray || modelName.substring(0, Swagger.envelopePrefixArrayPaged.length) === Swagger.envelopePrefixArrayPaged || modelName.substring(0, Swagger.envelopePrefixDictionary.length) === Swagger.envelopePrefixDictionary || modelName.substring(0, Swagger.envelopePrefixDictionaryPaged.length) === Swagger.envelopePrefixDictionaryPaged);
}, angular.module("apis-application.services").service("Swagger", [ "Utility", Swagger ]), 
function(angular) {
    function UserService($http, AuthService) {
        this.path = "api/users/", this.create = function(username) {
            var token = AuthService.getToken();
            return $http({
                method: "POST",
                url: this.path + "?token=" + token + "&username=" + username
            });
        }, this.edit = function(username, privileges) {
            var token = AuthService.getToken();
            return $http({
                method: "PUT",
                url: this.path + "?token=" + token + "&username=" + username,
                data: {
                    privileges: privileges
                }
            });
        }, this.get = function(id) {
            var token = AuthService.getToken();
            return $http({
                method: "GET",
                url: this.path + "?token=" + token + "&username=" + id
            });
        }, this.getList = function() {
            var token = AuthService.getToken();
            return $http({
                method: "GET",
                url: this.path + "?token=" + token
            });
        };
    }
    angular.module("apis-application.services").service("UserService", [ "$http", "AuthService", UserService ]);
}(window.angular), function(angular) {
    function Utility() {
        this.arrayMove = function(array, fromIndex, toIndex) {
            array.splice(toIndex, 0, array.splice(fromIndex, 1)[0]);
        }, this.arrayUp = function(array, fromIndex) {
            this.arrayMove(array, fromIndex, fromIndex - 1);
        }, this.arrayDown = function(array, fromIndex) {
            this.arrayMove(array, fromIndex, fromIndex + 1);
        }, this.arrayTop = function(array, fromIndex) {
            this.arrayMove(array, fromIndex, 0);
        }, this.arrayBottom = function(array, fromIndex) {
            this.arrayMove(array, fromIndex, array.length - 1);
        }, this.remove = function(collection, idx) {
            return angular.isArray(collection) ? collection.splice(idx, 1) : delete collection[idx], 
            !1;
        }, this.getURLParameter = function(name) {
            return decodeURIComponent((RegExp(name + "=(.+?)(&|$)").exec(location.search) || [ "" ])[1]);
        }, this.arrayToMap = function(array, key) {
            this.log("Switching array to map with key '" + key + "'");
            var map = {};
            return _.each(array, function(item) {
                map[item[key]] = item;
            }), map;
        }, this.mapToArray = function(map, keyName) {
            this.log("Switching map to array with key '" + keyName + "'");
            var array = [];
            return _.each(map, function(item, key) {
                keyName && (item[keyName] = key), array.push(item);
            }), array;
        }, this.log = function(message) {
            console && console.log && console.log(message);
        };
    }
    angular.module("apis-application.services").service("Utility", Utility);
}(window.angular), function(angular) {
    "use strict";
    function Validators() {
        return {
            alphaLower: /^[a-z]+$/,
            alphaUpper: /^[A-Z]+$/,
            alpha: /^[a-zA-Z]+$/i,
            numeric: /^\d+$/,
            alphaNumeric: /^[a-zA-Z0-9]+$/i,
            alphaNumericChars: /^[a-zA-Z0-9\-\.\:_]+$/i,
            camelCase: /^([a-z][a-zA-Z]*)*$/,
            camelCaseNumeric: /^([a-z][a-zA-Z0-9]*)*$/,
            alphaUnderscore: /^([a-zA-Z]+[a-zA-Z_]+)*$/,
            alphaNumericUnderscore: /^([a-zA-Z0-9]+[a-zA-Z0-9_]+)*$/,
            alphaLowerUnderscore: /^([a-z]+[a-z_]+)*$/,
            alphaUpperUnderscore: /^([A-Z]+[A-Z_]+)*$/,
            sqlTable: /^([a-zA-Z0-9_\@\#][a-zA-Z0-9_\@\#\$]*)*$/,
            domain: /^([a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\.)+[a-zA-Z]{2,}(\.[a-zA-Z]{2,})*$/,
            camelCaseNumericUnderscore: /^([a-z][a-zA-Z0-9_]*)*$/,
            camelCaseNumericUnderscorePeriod: /^([a-z][a-zA-Z0-9_\.]*)*$/,
            camelCaseNumericUnderscorePeriodHyphen: /^([a-z][a-zA-Z0-9_\-\.]*)*$/,
            camelCaseNumericChars: /^([a-z][a-zA-Z0-9_\-\.\:]*)*$/,
            date: /^[0-3][0-9]\/[0-1][0-9]\/[1-2][0-9][0-9][0-9]$/,
            dateUS: /^[0-3][0-9]\/[0-1][0-9]\/[1-2][0-9][0-9][0-9]$/,
            time: /^[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$/,
            hoursAndMinutes: /^[0-2][0-9]:[0-5][0-9]$/
        };
    }
    angular.module("apis-application.services").factory("Validators", Validators);
}(window.angular);